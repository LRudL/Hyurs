(require
 [hy.contrib.walk [let]]
 [utils [*]])
(import
  math
  random
  [utils [*]]
  stats)

(setv tau (* 2 math.pi))

(defn treelist->tag-val-lists
  [tl]
  """ This is the main data processing function for graphs. It starts with a
      standard treelist, as generated by functions in stats.hy. It calculates
      sumtree, which is the original treelist tl except:
      1. Node values are replaced with the sums of the subtree rooted at that
         node.
      2. If the combined value of the children of a node is less than the value
         of the node, a new sibling node is inserted with Uncategorised
         (a Lisp symbol) as its key and a value such that the sum of child
         values is now the parent node's value.
      3. The tree is extended so that all branches go to the same depth, by
         again inserting nodes with the Uncategorised key (and value of their
         parents) as necessary.
      This is done to preserve the invariants:
      1. Parent value = sum of child values
      2. Sum of all values at depth i = sum of all values at depth i'
      Next, the tree is converted into a list of (key, value) pairs,
      and with the help of some clever sorting these are conveniently
      partitioned into different lists depending on their length.

      The result is a list of lists containing (key, val) pairs for each level
      in the tree, where each level has the same sum (easy to align in graphs).
  """
  (let [sumtree (-> tl
                    (stats.sum-treelist)
                    (stats.sum-tl-fill-uncategorised)
                    (stats.treelist-extender
                     (stats.tl-max-depth tl)))]
    (-> sumtree
        ; ((fn [x] (do (print x) x))) ; debugger
        (stats.blown-up-treelist)
        (sort
         (fn [tree]
           (stats.tree-ranks sumtree
                             (stats.node-key tree))))
        (slice-by-len
         ; make it look at the length of the key, not key-val pair:
         first)
        rst))) ; take the rest because the first element is length zero lists

(defn tag-val-lists
  [mapping-name t1-str t2-str]
  (treelist->tag-val-lists (stats.times->treelist)))

(defn replace-uncategorised [l]
  """Replaced the Lisp symbol Uncategorised with False in the list l.
     This is done because False (equivalent to the Python value) interfaces
     better with Python code."""
  (mapl (fn [key]
          (if (= key 'Uncategorised)
            False
            key))
        l))

(defn nested-pie-ring
  [farc-fn labels vals cols cx cy start-r end-r start-angle]
  """ A helper function for the main pie chart generator below."""
  (setv dist/val (/ tau (sum vals)))
  (setv angle start-angle)
  (for [i (list (range (len vals)))]
    (let [col (get cols i)
          next-angle (+ angle
                        (* dist/val
                           (get vals i)))]
      (farc-fn cx
               cy
               start-r
               end-r
               angle
               next-angle
               col
               (if col (get labels i) ""))
      (setv angle next-angle))))

(defn nested-pie-chart
  [farc-fn col-fn vals-by-len cx cy start-radius radius-step]
  """ARGUMENTS:
  - farc-fn is a filled arc function, taking:
      cx cy radius-1 radius-2 angle-1-in-radians angle-2-in-radians color-or-false label-text
    and is responsible for collecting the output. If color-or-false is false, farc-fn
    should output the background colour.
  - col-fn is a function that takes in h-tags and returns an RGB color
  - vals-by-len is a list of tuples of h-tag, value pairs, where the ith
    element of the list is all such pairs where the h-tag has (i+1) levels,
    and the special value False has been inserted as fillers when on the next
    level something is uncategorised (e.g. a:b has value 3, but a:b:c has value
    2 and no other x such that a:b:x exists; then add False with value 1 to the
    second list in vals-by-len)
  - cx/cy are the coordinates of the centre of the graph
  - start-radius is the length from the centre to leave blank before the innermost ring
  - radius-step is the width of each ring
     RETURNS:
  - a bounding box for the chart, of the form [x1, y1, x2, y2]
  (output is assumed to be collected by farc-fn)
  """
  (defn pie-ring-iter
    [vals-by-len i]
    (if (!= i 0)
      (do
        (let [tags-vals (last vals-by-len)
              htags (mapl first tags-vals)]
          (nested-pie-ring farc-fn
                           (replace-uncategorised
                            (mapl (get-ith (- i 1))
                                  htags)) ; label is only current level of the htag
                           (mapl second
                                 tags-vals) ; this gives the values
                           (mapl col-fn
                                 htags)
                           cx
                           cy
                           (+ start-radius (* radius-step (- i 1)))
                           (+ start-radius (* radius-step i))
                           0))
        (pie-ring-iter (butlastl vals-by-len) (dec i)))))
  (pie-ring-iter vals-by-len
                 (len vals-by-len))
  ; ^ the reason we go backwards in the above is so that the chart can be drawn
  ;   even if only circle slices are supported (not "pizza rim"-shaped ones);
  ;   going 0 up would mean later slices would then go on top of earlier ones.
  (let [rings (len vals-by-len)
        total-radius (+ start-radius (* radius-step rings))]
    [(- cx total-radius) (- cy total-radius)
     (+ cx total-radius) (+ cy total-radius)]))

(defn flame-chart
  [rect-fn col-fn vals-by-len cx cy height layer-width]
  """ARGUMENTS:
  - rect-fn is a filled rectangle function, taking:
      x1 y1 x2 y2 color label-text
    and is responsible for collecting the output.
  - col-fn is a function that takes in h-tags and returns an RGB color
  - vals-by-len is a list of dictionaries from h-tag to value, where the ith
    element of the list is all h-tags of (i+1) elements
  - cx/cy are the coordinates of the corner of the graph
  - height is the height of the graph (positive or negative to change direction)
  - layer-width is the width of one layer in the flame chart
  """
  (error "Flame chart not implemented."))

(defn labelled-filled-arc-fn-gen
  [filled-arc-fn angled-text-fn background-col]
  (fn [cx cy r1 r2 ang1 ang2 col label]
    (if label
      (let [fill-col (if col col background-col)]
        (filled-arc-fn cx cy r1 r2 ang1 ang2 fill-col)
        (let [r (/ (+ r1 r2) 2)
              ang (/ (+ ang1 ang2) 2)]
          (angled-text-fn (+ cx (* r (math.cos ang)))
                          (- cy (* r (math.sin ang)))
                          (if (< (abs (- ang2 ang1))
                                 (/ tau 16)) ; ARBITRARY CONSTANT - UH OH
                            (if (and (< ang (* tau 3/4))
                                     (> ang (/ tau 4)))
                              (+ ang (/ tau 2))
                              ang)
                            (if (< ang (/ tau 2))
                              (- ang (/ tau 4))
                              (+ ang (/ tau 4))))
                          label)))
      False)))

(defn rand-col-fn [htag]
  (col->hex (map (fn [x] (random.randint 0 255))
                 ['three 'element 'list])))


(defn make-pie-chart
  [tl farc-fn col-fn cx cy start-radius radius-step]
  (nested-pie-chart farc-fn
                    col-fn
                    (treelist->tag-val-lists tl)
                    cx
                    cy
                    start-radius
                    radius-step))
